# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateFederatedCredentials {
  _avg: FederatedCredentialsAvgAggregate
  _count: FederatedCredentialsCountAggregate
  _max: FederatedCredentialsMaxAggregate
  _min: FederatedCredentialsMinAggregate
  _sum: FederatedCredentialsSumAggregate
}

type AggregateTodo {
  _avg: TodoAvgAggregate
  _count: TodoCountAggregate
  _max: TodoMaxAggregate
  _min: TodoMinAggregate
  _sum: TodoSumAggregate
}

type AggregateUser {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

input EnumRoleNullableListFilter {
  equals: [Role!]
  has: Role
  hasEvery: [Role!]
  hasSome: [Role!]
  isEmpty: Boolean
}

type FederatedCredentials {
  User: User!
  id: Int!
  provider: String!
  subject: String!
  userId: Int!
}

type FederatedCredentialsAvgAggregate {
  id: Float
  userId: Float
}

input FederatedCredentialsAvgOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

type FederatedCredentialsCountAggregate {
  _all: Int!
  id: Int!
  provider: Int!
  subject: Int!
  userId: Int!
}

input FederatedCredentialsCountOrderByAggregateInput {
  id: SortOrder
  provider: SortOrder
  subject: SortOrder
  userId: SortOrder
}

input FederatedCredentialsCreateInput {
  User: UserCreateNestedOneWithoutFederatedCredentialsInput!
  provider: String!
  subject: String!
}

input FederatedCredentialsCreateManyInput {
  id: Int
  provider: String!
  subject: String!
  userId: Int!
}

input FederatedCredentialsCreateManyUserInput {
  id: Int
  provider: String!
  subject: String!
}

input FederatedCredentialsCreateManyUserInputEnvelope {
  data: [FederatedCredentialsCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input FederatedCredentialsCreateNestedManyWithoutUserInput {
  connect: [FederatedCredentialsWhereUniqueInput!]
  connectOrCreate: [FederatedCredentialsCreateOrConnectWithoutUserInput!]
  create: [FederatedCredentialsCreateWithoutUserInput!]
  createMany: FederatedCredentialsCreateManyUserInputEnvelope
}

input FederatedCredentialsCreateOrConnectWithoutUserInput {
  create: FederatedCredentialsCreateWithoutUserInput!
  where: FederatedCredentialsWhereUniqueInput!
}

input FederatedCredentialsCreateWithoutUserInput {
  provider: String!
  subject: String!
}

type FederatedCredentialsGroupBy {
  _avg: FederatedCredentialsAvgAggregate
  _count: FederatedCredentialsCountAggregate
  _max: FederatedCredentialsMaxAggregate
  _min: FederatedCredentialsMinAggregate
  _sum: FederatedCredentialsSumAggregate
  id: Int!
  provider: String!
  subject: String!
  userId: Int!
}

input FederatedCredentialsListRelationFilter {
  every: FederatedCredentialsWhereInput
  none: FederatedCredentialsWhereInput
  some: FederatedCredentialsWhereInput
}

type FederatedCredentialsMaxAggregate {
  id: Int
  provider: String
  subject: String
  userId: Int
}

input FederatedCredentialsMaxOrderByAggregateInput {
  id: SortOrder
  provider: SortOrder
  subject: SortOrder
  userId: SortOrder
}

type FederatedCredentialsMinAggregate {
  id: Int
  provider: String
  subject: String
  userId: Int
}

input FederatedCredentialsMinOrderByAggregateInput {
  id: SortOrder
  provider: SortOrder
  subject: SortOrder
  userId: SortOrder
}

input FederatedCredentialsOrderByRelationAggregateInput {
  _count: SortOrder
}

input FederatedCredentialsOrderByWithAggregationInput {
  _avg: FederatedCredentialsAvgOrderByAggregateInput
  _count: FederatedCredentialsCountOrderByAggregateInput
  _max: FederatedCredentialsMaxOrderByAggregateInput
  _min: FederatedCredentialsMinOrderByAggregateInput
  _sum: FederatedCredentialsSumOrderByAggregateInput
  id: SortOrder
  provider: SortOrder
  subject: SortOrder
  userId: SortOrder
}

input FederatedCredentialsOrderByWithRelationInput {
  User: UserOrderByWithRelationInput
  id: SortOrder
  provider: SortOrder
  subject: SortOrder
  userId: SortOrder
}

enum FederatedCredentialsScalarFieldEnum {
  id
  provider
  subject
  userId
}

input FederatedCredentialsScalarWhereInput {
  AND: [FederatedCredentialsScalarWhereInput!]
  NOT: [FederatedCredentialsScalarWhereInput!]
  OR: [FederatedCredentialsScalarWhereInput!]
  id: IntFilter
  provider: StringFilter
  subject: StringFilter
  userId: IntFilter
}

input FederatedCredentialsScalarWhereWithAggregatesInput {
  AND: [FederatedCredentialsScalarWhereWithAggregatesInput!]
  NOT: [FederatedCredentialsScalarWhereWithAggregatesInput!]
  OR: [FederatedCredentialsScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  provider: StringWithAggregatesFilter
  subject: StringWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type FederatedCredentialsSumAggregate {
  id: Int
  userId: Int
}

input FederatedCredentialsSumOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

input FederatedCredentialsUpdateInput {
  User: UserUpdateOneRequiredWithoutFederatedCredentialsInput
  provider: StringFieldUpdateOperationsInput
  subject: StringFieldUpdateOperationsInput
}

input FederatedCredentialsUpdateManyMutationInput {
  provider: StringFieldUpdateOperationsInput
  subject: StringFieldUpdateOperationsInput
}

input FederatedCredentialsUpdateManyWithWhereWithoutUserInput {
  data: FederatedCredentialsUpdateManyMutationInput!
  where: FederatedCredentialsScalarWhereInput!
}

input FederatedCredentialsUpdateManyWithoutUserInput {
  connect: [FederatedCredentialsWhereUniqueInput!]
  connectOrCreate: [FederatedCredentialsCreateOrConnectWithoutUserInput!]
  create: [FederatedCredentialsCreateWithoutUserInput!]
  createMany: FederatedCredentialsCreateManyUserInputEnvelope
  delete: [FederatedCredentialsWhereUniqueInput!]
  deleteMany: [FederatedCredentialsScalarWhereInput!]
  disconnect: [FederatedCredentialsWhereUniqueInput!]
  set: [FederatedCredentialsWhereUniqueInput!]
  update: [FederatedCredentialsUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [FederatedCredentialsUpdateManyWithWhereWithoutUserInput!]
  upsert: [FederatedCredentialsUpsertWithWhereUniqueWithoutUserInput!]
}

input FederatedCredentialsUpdateWithWhereUniqueWithoutUserInput {
  data: FederatedCredentialsUpdateWithoutUserInput!
  where: FederatedCredentialsWhereUniqueInput!
}

input FederatedCredentialsUpdateWithoutUserInput {
  provider: StringFieldUpdateOperationsInput
  subject: StringFieldUpdateOperationsInput
}

input FederatedCredentialsUpsertWithWhereUniqueWithoutUserInput {
  create: FederatedCredentialsCreateWithoutUserInput!
  update: FederatedCredentialsUpdateWithoutUserInput!
  where: FederatedCredentialsWhereUniqueInput!
}

input FederatedCredentialsWhereInput {
  AND: [FederatedCredentialsWhereInput!]
  NOT: [FederatedCredentialsWhereInput!]
  OR: [FederatedCredentialsWhereInput!]
  User: UserRelationFilter
  id: IntFilter
  provider: StringFilter
  subject: StringFilter
  userId: IntFilter
}

input FederatedCredentialsWhereUniqueInput {
  id: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input MessageInput {
  message: String!
}

type Mutation {
  addNewMessage(message: MessageInput!): Boolean!
  createFederatedCredentials(data: FederatedCredentialsCreateInput!): FederatedCredentials!
  createManyFederatedCredentials(data: [FederatedCredentialsCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyTodo(data: [TodoCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUser(data: [UserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createTodo(data: TodoCreateInput!): Todo!
  createUser(data: UserCreateInput!): User!
  deleteFederatedCredentials(where: FederatedCredentialsWhereUniqueInput!): FederatedCredentials
  deleteManyFederatedCredentials(where: FederatedCredentialsWhereInput): AffectedRowsOutput!
  deleteManyTodo(where: TodoWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteTodo(where: TodoWhereUniqueInput!): Todo
  deleteUser(where: UserWhereUniqueInput!): User
  updateFederatedCredentials(data: FederatedCredentialsUpdateInput!, where: FederatedCredentialsWhereUniqueInput!): FederatedCredentials
  updateManyFederatedCredentials(data: FederatedCredentialsUpdateManyMutationInput!, where: FederatedCredentialsWhereInput): AffectedRowsOutput!
  updateManyTodo(data: TodoUpdateManyMutationInput!, where: TodoWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateTodo(data: TodoUpdateInput!, where: TodoWhereUniqueInput!): Todo
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertFederatedCredentials(create: FederatedCredentialsCreateInput!, update: FederatedCredentialsUpdateInput!, where: FederatedCredentialsWhereUniqueInput!): FederatedCredentials!
  upsertTodo(create: TodoCreateInput!, update: TodoUpdateInput!, where: TodoWhereUniqueInput!): Todo!
  upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type NewMessagePayload {
  message: String!
  user: String!
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Query {
  aggregateFederatedCredentials(cursor: FederatedCredentialsWhereUniqueInput, orderBy: [FederatedCredentialsOrderByWithRelationInput!], skip: Int, take: Int, where: FederatedCredentialsWhereInput): AggregateFederatedCredentials!
  aggregateTodo(cursor: TodoWhereUniqueInput, orderBy: [TodoOrderByWithRelationInput!], skip: Int, take: Int, where: TodoWhereInput): AggregateTodo!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  findFirstFederatedCredentials(cursor: FederatedCredentialsWhereUniqueInput, distinct: [FederatedCredentialsScalarFieldEnum!], orderBy: [FederatedCredentialsOrderByWithRelationInput!], skip: Int, take: Int, where: FederatedCredentialsWhereInput): FederatedCredentials
  findFirstTodo(cursor: TodoWhereUniqueInput, distinct: [TodoScalarFieldEnum!], orderBy: [TodoOrderByWithRelationInput!], skip: Int, take: Int, where: TodoWhereInput): Todo
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  findManyFederatedCredentials(cursor: FederatedCredentialsWhereUniqueInput, distinct: [FederatedCredentialsScalarFieldEnum!], orderBy: [FederatedCredentialsOrderByWithRelationInput!], skip: Int, take: Int, where: FederatedCredentialsWhereInput): [FederatedCredentials!]!
  findUniqueFederatedCredentials(where: FederatedCredentialsWhereUniqueInput!): FederatedCredentials
  getJwt: String
  groupByFederatedCredentials(by: [FederatedCredentialsScalarFieldEnum!]!, having: FederatedCredentialsScalarWhereWithAggregatesInput, orderBy: [FederatedCredentialsOrderByWithAggregationInput!], skip: Int, take: Int, where: FederatedCredentialsWhereInput): [FederatedCredentialsGroupBy!]!
  groupByTodo(by: [TodoScalarFieldEnum!]!, having: TodoScalarWhereWithAggregatesInput, orderBy: [TodoOrderByWithAggregationInput!], skip: Int, take: Int, where: TodoWhereInput): [TodoGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  todo(where: TodoWhereUniqueInput!): Todo
  todos(cursor: TodoWhereUniqueInput, distinct: [TodoScalarFieldEnum!], orderBy: [TodoOrderByWithRelationInput!], skip: Int, take: Int, where: TodoWhereInput): [Todo!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

enum Role {
  ADMIN
  CAPTAIN
  OWNER
  USER
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Subscription {
  newMessage(id: ID!): NewMessagePayload!
}

type Todo {
  User: User
  completed: Boolean!
  id: Int!
  ownerId: Int
  title: String!
}

type TodoAvgAggregate {
  id: Float
  ownerId: Float
}

input TodoAvgOrderByAggregateInput {
  id: SortOrder
  ownerId: SortOrder
}

type TodoCountAggregate {
  _all: Int!
  completed: Int!
  id: Int!
  ownerId: Int!
  title: Int!
}

input TodoCountOrderByAggregateInput {
  completed: SortOrder
  id: SortOrder
  ownerId: SortOrder
  title: SortOrder
}

input TodoCreateInput {
  User: UserCreateNestedOneWithoutTodosInput
  completed: Boolean!
  title: String!
}

input TodoCreateManyInput {
  completed: Boolean!
  id: Int
  ownerId: Int
  title: String!
}

input TodoCreateManyUserInput {
  completed: Boolean!
  id: Int
  title: String!
}

input TodoCreateManyUserInputEnvelope {
  data: [TodoCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input TodoCreateNestedManyWithoutUserInput {
  connect: [TodoWhereUniqueInput!]
  connectOrCreate: [TodoCreateOrConnectWithoutUserInput!]
  create: [TodoCreateWithoutUserInput!]
  createMany: TodoCreateManyUserInputEnvelope
}

input TodoCreateOrConnectWithoutUserInput {
  create: TodoCreateWithoutUserInput!
  where: TodoWhereUniqueInput!
}

input TodoCreateWithoutUserInput {
  completed: Boolean!
  title: String!
}

type TodoGroupBy {
  _avg: TodoAvgAggregate
  _count: TodoCountAggregate
  _max: TodoMaxAggregate
  _min: TodoMinAggregate
  _sum: TodoSumAggregate
  completed: Boolean!
  id: Int!
  ownerId: Int
  title: String!
}

input TodoListRelationFilter {
  every: TodoWhereInput
  none: TodoWhereInput
  some: TodoWhereInput
}

type TodoMaxAggregate {
  completed: Boolean
  id: Int
  ownerId: Int
  title: String
}

input TodoMaxOrderByAggregateInput {
  completed: SortOrder
  id: SortOrder
  ownerId: SortOrder
  title: SortOrder
}

type TodoMinAggregate {
  completed: Boolean
  id: Int
  ownerId: Int
  title: String
}

input TodoMinOrderByAggregateInput {
  completed: SortOrder
  id: SortOrder
  ownerId: SortOrder
  title: SortOrder
}

input TodoOrderByRelationAggregateInput {
  _count: SortOrder
}

input TodoOrderByWithAggregationInput {
  _avg: TodoAvgOrderByAggregateInput
  _count: TodoCountOrderByAggregateInput
  _max: TodoMaxOrderByAggregateInput
  _min: TodoMinOrderByAggregateInput
  _sum: TodoSumOrderByAggregateInput
  completed: SortOrder
  id: SortOrder
  ownerId: SortOrder
  title: SortOrder
}

input TodoOrderByWithRelationInput {
  User: UserOrderByWithRelationInput
  completed: SortOrder
  id: SortOrder
  ownerId: SortOrder
  title: SortOrder
}

enum TodoScalarFieldEnum {
  completed
  id
  ownerId
  title
}

input TodoScalarWhereInput {
  AND: [TodoScalarWhereInput!]
  NOT: [TodoScalarWhereInput!]
  OR: [TodoScalarWhereInput!]
  completed: BoolFilter
  id: IntFilter
  ownerId: IntNullableFilter
  title: StringFilter
}

input TodoScalarWhereWithAggregatesInput {
  AND: [TodoScalarWhereWithAggregatesInput!]
  NOT: [TodoScalarWhereWithAggregatesInput!]
  OR: [TodoScalarWhereWithAggregatesInput!]
  completed: BoolWithAggregatesFilter
  id: IntWithAggregatesFilter
  ownerId: IntNullableWithAggregatesFilter
  title: StringWithAggregatesFilter
}

type TodoSumAggregate {
  id: Int
  ownerId: Int
}

input TodoSumOrderByAggregateInput {
  id: SortOrder
  ownerId: SortOrder
}

input TodoUpdateInput {
  User: UserUpdateOneWithoutTodosInput
  completed: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input TodoUpdateManyMutationInput {
  completed: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input TodoUpdateManyWithWhereWithoutUserInput {
  data: TodoUpdateManyMutationInput!
  where: TodoScalarWhereInput!
}

input TodoUpdateManyWithoutUserInput {
  connect: [TodoWhereUniqueInput!]
  connectOrCreate: [TodoCreateOrConnectWithoutUserInput!]
  create: [TodoCreateWithoutUserInput!]
  createMany: TodoCreateManyUserInputEnvelope
  delete: [TodoWhereUniqueInput!]
  deleteMany: [TodoScalarWhereInput!]
  disconnect: [TodoWhereUniqueInput!]
  set: [TodoWhereUniqueInput!]
  update: [TodoUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [TodoUpdateManyWithWhereWithoutUserInput!]
  upsert: [TodoUpsertWithWhereUniqueWithoutUserInput!]
}

input TodoUpdateWithWhereUniqueWithoutUserInput {
  data: TodoUpdateWithoutUserInput!
  where: TodoWhereUniqueInput!
}

input TodoUpdateWithoutUserInput {
  completed: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input TodoUpsertWithWhereUniqueWithoutUserInput {
  create: TodoCreateWithoutUserInput!
  update: TodoUpdateWithoutUserInput!
  where: TodoWhereUniqueInput!
}

input TodoWhereInput {
  AND: [TodoWhereInput!]
  NOT: [TodoWhereInput!]
  OR: [TodoWhereInput!]
  User: UserRelationFilter
  completed: BoolFilter
  id: IntFilter
  ownerId: IntNullableFilter
  title: StringFilter
}

input TodoWhereUniqueInput {
  id: Int
}

type User {
  _count: UserCount
  email: String!
  emailVerified: Boolean!
  federatedCredentials(cursor: FederatedCredentialsWhereUniqueInput, distinct: [FederatedCredentialsScalarFieldEnum!], orderBy: [FederatedCredentialsOrderByWithRelationInput!], skip: Int, take: Int, where: FederatedCredentialsWhereInput): [FederatedCredentials!]!
  id: Int!
  name: String!
  roles: [Role!]!
  todos(cursor: TodoWhereUniqueInput, distinct: [TodoScalarFieldEnum!], orderBy: [TodoOrderByWithRelationInput!], skip: Int, take: Int, where: TodoWhereInput): [Todo!]!
  username: String!
}

type UserAvgAggregate {
  id: Float
}

input UserAvgOrderByAggregateInput {
  id: SortOrder
}

type UserCount {
  federatedCredentials: Int!
  todos: Int!
}

type UserCountAggregate {
  _all: Int!
  accessToken: Int!
  email: Int!
  emailVerified: Int!
  hashedPassword: Int!
  id: Int!
  idToken: Int!
  jwt: Int!
  name: Int!
  refreshToken: Int!
  roles: Int!
  salt: Int!
  username: Int!
}

input UserCountOrderByAggregateInput {
  accessToken: SortOrder
  email: SortOrder
  emailVerified: SortOrder
  hashedPassword: SortOrder
  id: SortOrder
  idToken: SortOrder
  jwt: SortOrder
  name: SortOrder
  refreshToken: SortOrder
  roles: SortOrder
  salt: SortOrder
  username: SortOrder
}

input UserCreateInput {
  accessToken: String
  email: String!
  emailVerified: Boolean!
  federatedCredentials: FederatedCredentialsCreateNestedManyWithoutUserInput
  hashedPassword: String
  idToken: String
  jwt: String
  name: String!
  refreshToken: String
  roles: UserCreaterolesInput
  salt: String
  todos: TodoCreateNestedManyWithoutUserInput
  username: String!
}

input UserCreateManyInput {
  accessToken: String
  email: String!
  emailVerified: Boolean!
  hashedPassword: String
  id: Int
  idToken: String
  jwt: String
  name: String!
  refreshToken: String
  roles: UserCreaterolesInput
  salt: String
  username: String!
}

input UserCreateNestedOneWithoutFederatedCredentialsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutFederatedCredentialsInput
  create: UserCreateWithoutFederatedCredentialsInput
}

input UserCreateNestedOneWithoutTodosInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutTodosInput
  create: UserCreateWithoutTodosInput
}

input UserCreateOrConnectWithoutFederatedCredentialsInput {
  create: UserCreateWithoutFederatedCredentialsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutTodosInput {
  create: UserCreateWithoutTodosInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutFederatedCredentialsInput {
  accessToken: String
  email: String!
  emailVerified: Boolean!
  hashedPassword: String
  idToken: String
  jwt: String
  name: String!
  refreshToken: String
  roles: UserCreaterolesInput
  salt: String
  todos: TodoCreateNestedManyWithoutUserInput
  username: String!
}

input UserCreateWithoutTodosInput {
  accessToken: String
  email: String!
  emailVerified: Boolean!
  federatedCredentials: FederatedCredentialsCreateNestedManyWithoutUserInput
  hashedPassword: String
  idToken: String
  jwt: String
  name: String!
  refreshToken: String
  roles: UserCreaterolesInput
  salt: String
  username: String!
}

input UserCreaterolesInput {
  set: [Role!]!
}

type UserGroupBy {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
  accessToken: String
  email: String!
  emailVerified: Boolean!
  hashedPassword: String
  id: Int!
  idToken: String
  jwt: String
  name: String!
  refreshToken: String
  roles: [Role!]
  salt: String
  username: String!
}

type UserMaxAggregate {
  accessToken: String
  email: String
  emailVerified: Boolean
  hashedPassword: String
  id: Int
  idToken: String
  jwt: String
  name: String
  refreshToken: String
  salt: String
  username: String
}

input UserMaxOrderByAggregateInput {
  accessToken: SortOrder
  email: SortOrder
  emailVerified: SortOrder
  hashedPassword: SortOrder
  id: SortOrder
  idToken: SortOrder
  jwt: SortOrder
  name: SortOrder
  refreshToken: SortOrder
  salt: SortOrder
  username: SortOrder
}

type UserMinAggregate {
  accessToken: String
  email: String
  emailVerified: Boolean
  hashedPassword: String
  id: Int
  idToken: String
  jwt: String
  name: String
  refreshToken: String
  salt: String
  username: String
}

input UserMinOrderByAggregateInput {
  accessToken: SortOrder
  email: SortOrder
  emailVerified: SortOrder
  hashedPassword: SortOrder
  id: SortOrder
  idToken: SortOrder
  jwt: SortOrder
  name: SortOrder
  refreshToken: SortOrder
  salt: SortOrder
  username: SortOrder
}

input UserOrderByWithAggregationInput {
  _avg: UserAvgOrderByAggregateInput
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  _sum: UserSumOrderByAggregateInput
  accessToken: SortOrder
  email: SortOrder
  emailVerified: SortOrder
  hashedPassword: SortOrder
  id: SortOrder
  idToken: SortOrder
  jwt: SortOrder
  name: SortOrder
  refreshToken: SortOrder
  roles: SortOrder
  salt: SortOrder
  username: SortOrder
}

input UserOrderByWithRelationInput {
  accessToken: SortOrder
  email: SortOrder
  emailVerified: SortOrder
  federatedCredentials: FederatedCredentialsOrderByRelationAggregateInput
  hashedPassword: SortOrder
  id: SortOrder
  idToken: SortOrder
  jwt: SortOrder
  name: SortOrder
  refreshToken: SortOrder
  roles: SortOrder
  salt: SortOrder
  todos: TodoOrderByRelationAggregateInput
  username: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  accessToken
  email
  emailVerified
  hashedPassword
  id
  idToken
  jwt
  name
  refreshToken
  roles
  salt
  username
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  accessToken: StringNullableWithAggregatesFilter
  email: StringWithAggregatesFilter
  emailVerified: BoolWithAggregatesFilter
  hashedPassword: StringNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  idToken: StringNullableWithAggregatesFilter
  jwt: StringNullableWithAggregatesFilter
  name: StringWithAggregatesFilter
  refreshToken: StringNullableWithAggregatesFilter
  roles: EnumRoleNullableListFilter
  salt: StringNullableWithAggregatesFilter
  username: StringWithAggregatesFilter
}

type UserSumAggregate {
  id: Int
}

input UserSumOrderByAggregateInput {
  id: SortOrder
}

input UserUpdateInput {
  accessToken: NullableStringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: BoolFieldUpdateOperationsInput
  federatedCredentials: FederatedCredentialsUpdateManyWithoutUserInput
  hashedPassword: NullableStringFieldUpdateOperationsInput
  idToken: NullableStringFieldUpdateOperationsInput
  jwt: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  refreshToken: NullableStringFieldUpdateOperationsInput
  roles: UserUpdaterolesInput
  salt: NullableStringFieldUpdateOperationsInput
  todos: TodoUpdateManyWithoutUserInput
  username: StringFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  accessToken: NullableStringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: BoolFieldUpdateOperationsInput
  hashedPassword: NullableStringFieldUpdateOperationsInput
  idToken: NullableStringFieldUpdateOperationsInput
  jwt: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  refreshToken: NullableStringFieldUpdateOperationsInput
  roles: UserUpdaterolesInput
  salt: NullableStringFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutFederatedCredentialsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutFederatedCredentialsInput
  create: UserCreateWithoutFederatedCredentialsInput
  update: UserUpdateWithoutFederatedCredentialsInput
  upsert: UserUpsertWithoutFederatedCredentialsInput
}

input UserUpdateOneWithoutTodosInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutTodosInput
  create: UserCreateWithoutTodosInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutTodosInput
  upsert: UserUpsertWithoutTodosInput
}

input UserUpdateWithoutFederatedCredentialsInput {
  accessToken: NullableStringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: BoolFieldUpdateOperationsInput
  hashedPassword: NullableStringFieldUpdateOperationsInput
  idToken: NullableStringFieldUpdateOperationsInput
  jwt: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  refreshToken: NullableStringFieldUpdateOperationsInput
  roles: UserUpdaterolesInput
  salt: NullableStringFieldUpdateOperationsInput
  todos: TodoUpdateManyWithoutUserInput
  username: StringFieldUpdateOperationsInput
}

input UserUpdateWithoutTodosInput {
  accessToken: NullableStringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: BoolFieldUpdateOperationsInput
  federatedCredentials: FederatedCredentialsUpdateManyWithoutUserInput
  hashedPassword: NullableStringFieldUpdateOperationsInput
  idToken: NullableStringFieldUpdateOperationsInput
  jwt: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  refreshToken: NullableStringFieldUpdateOperationsInput
  roles: UserUpdaterolesInput
  salt: NullableStringFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input UserUpdaterolesInput {
  push: [Role!]
  set: [Role!]
}

input UserUpsertWithoutFederatedCredentialsInput {
  create: UserCreateWithoutFederatedCredentialsInput!
  update: UserUpdateWithoutFederatedCredentialsInput!
}

input UserUpsertWithoutTodosInput {
  create: UserCreateWithoutTodosInput!
  update: UserUpdateWithoutTodosInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  accessToken: StringNullableFilter
  email: StringFilter
  emailVerified: BoolFilter
  federatedCredentials: FederatedCredentialsListRelationFilter
  hashedPassword: StringNullableFilter
  id: IntFilter
  idToken: StringNullableFilter
  jwt: StringNullableFilter
  name: StringFilter
  refreshToken: StringNullableFilter
  roles: EnumRoleNullableListFilter
  salt: StringNullableFilter
  todos: TodoListRelationFilter
  username: StringFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
  username: String
}
